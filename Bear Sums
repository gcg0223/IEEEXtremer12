Bear Sums
Time limit: 9000 ms
Memory limit: 256 MB

Mitsos the bear is challenging his brother Vangelis with a mathematical task. Mitsos provides a list of integers L and another integer value S,then he asks Vangelis to check if there are any two items in the list L whose sum is equal to the integer S. 
Since Vangelis is a confident engineer, he decided to write a program that would do all the computations for him and skip the trouble of thinking. Your task is to help Vangelis write a program that reads the input list L and the integer S and produces either the solution to the problem or provides an error message when there is no solution available. Standard input 
On the first line there will be an integer number T (representing the number of test cases) followed by 22 input lines for each test case: 
•	On the first line of each test case, there will be 2 integers S and E, where S is the expected sum and E is the number of elements in the list. 
•	On the second line, there will be E integers separated by a space. Each integer represents an element of the list L. The elements are not sorted in any way and some could have the same value. In cases where the number E is 0, the second line will be empty. 
All values for the elements of list L will be in the same range as the value S. Standard output 
For each test case you will have to write one line that contains: 
•	If there is an unique solution: Write two elements, x and y of the list L, separated by a single space, such that x+y=S and x≤y. 
•	If there are multiple solutions: Pick the first complete pair that appears on the list and provides the correct sum. Print the two list elements forming this pair in increasing order, as above. 
•	If there is no solution: Print the error message  !OK.  
Constraints and notes 
•	1≤T≤1000  
•	−10^6<S<10^6
•	0≤E≤2⋅10^4
•	The sum of values of E is at most 10^7 
 
 

代码：
#include<bits/stdc++.h>
#include<iostream>
//#include<cmath>
//#include<cstring>
//#include<map>
//#include<algorithm>
//#include<numeric>
//#include<vector>
//#include<queue>

using namespace std;
const int L=2e6+1;
const int W=1e6-1;
char cur[L];
int pos[L];
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        memset(cur,0,sizeof(cur));
        memset(pos,0x3f,sizeof(pos));//初始化无穷大,可以用0xff
        int S,E;
        cin>>S>>E;
        int *a=new int[E];
        //int a[10];
        for(int i=0;i<E;i++)
        {
            scanf("%d",&a[i]);
            cur[W+a[i]]++;
            //是否存在过
            if(i<pos[W+a[i]])
            {
                pos[W+a[i]]=i;
            }//最小位置
        }
        bool ju=false;;
        for(int i=0;i<E;i++)
        {
            int num2=S-a[i];
            if(i<=pos[W+num2])
                continue;//找后面的那个对应的是不是在前面
            if(num2==a[i])
            {
                if(cur[W+num2]>1)//相同要多个1
                {
                    ju=true;
                    if(a[i]<num2)
                        cout<<a[i]<<" "<<num2<<endl;
                    else
                        cout<<num2<<" "<<a[i]<<endl;
                    break;
                }
            }
            else
            {
                if(cur[W+num2]>0)//不同只要有一个
                {
                    ju=true;
                    if(a[i]<num2)
                        cout<<a[i]<<" "<<num2<<endl;
                    else
                        cout<<num2<<" "<<a[i]<<endl;
                    break;
                }
            }

        }
        if(!ju)
        {
            cout<<"!OK"<<endl;
        }
        delete []a;
    }
}
